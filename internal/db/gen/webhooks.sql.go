// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: webhooks.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countWebhookDeliveries = `-- name: CountWebhookDeliveries :one
SELECT COUNT(*) FROM webhook_deliveries WHERE webhook_id = $1
`

func (q *Queries) CountWebhookDeliveries(ctx context.Context, webhookID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countWebhookDeliveries, webhookID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createWebhook = `-- name: CreateWebhook :one
INSERT INTO webhooks (url, description, enabled, events, project_id, environments, secret, max_retries, timeout_seconds)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, url, description, enabled, events, project_id, environments, secret, max_retries, timeout_seconds, created_at, updated_at, last_triggered_at
`

type CreateWebhookParams struct {
	Url            string      `json:"url"`
	Description    pgtype.Text `json:"description"`
	Enabled        bool        `json:"enabled"`
	Events         []string    `json:"events"`
	ProjectID      pgtype.UUID `json:"project_id"`
	Environments   []string    `json:"environments"`
	Secret         string      `json:"secret"`
	MaxRetries     int32       `json:"max_retries"`
	TimeoutSeconds int32       `json:"timeout_seconds"`
}

func (q *Queries) CreateWebhook(ctx context.Context, arg CreateWebhookParams) (Webhook, error) {
	row := q.db.QueryRow(ctx, createWebhook,
		arg.Url,
		arg.Description,
		arg.Enabled,
		arg.Events,
		arg.ProjectID,
		arg.Environments,
		arg.Secret,
		arg.MaxRetries,
		arg.TimeoutSeconds,
	)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Description,
		&i.Enabled,
		&i.Events,
		&i.ProjectID,
		&i.Environments,
		&i.Secret,
		&i.MaxRetries,
		&i.TimeoutSeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastTriggeredAt,
	)
	return i, err
}

const createWebhookDelivery = `-- name: CreateWebhookDelivery :one
INSERT INTO webhook_deliveries (
  webhook_id, 
  event_type, 
  payload, 
  status_code, 
  response_body, 
  error_message, 
  duration_ms, 
  success, 
  retry_count
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, webhook_id, event_type, payload, timestamp, status_code, response_body, error_message, duration_ms, success, retry_count
`

type CreateWebhookDeliveryParams struct {
	WebhookID    pgtype.UUID `json:"webhook_id"`
	EventType    string      `json:"event_type"`
	Payload      []byte      `json:"payload"`
	StatusCode   pgtype.Int4 `json:"status_code"`
	ResponseBody pgtype.Text `json:"response_body"`
	ErrorMessage pgtype.Text `json:"error_message"`
	DurationMs   pgtype.Int4 `json:"duration_ms"`
	Success      bool        `json:"success"`
	RetryCount   int32       `json:"retry_count"`
}

func (q *Queries) CreateWebhookDelivery(ctx context.Context, arg CreateWebhookDeliveryParams) (WebhookDelivery, error) {
	row := q.db.QueryRow(ctx, createWebhookDelivery,
		arg.WebhookID,
		arg.EventType,
		arg.Payload,
		arg.StatusCode,
		arg.ResponseBody,
		arg.ErrorMessage,
		arg.DurationMs,
		arg.Success,
		arg.RetryCount,
	)
	var i WebhookDelivery
	err := row.Scan(
		&i.ID,
		&i.WebhookID,
		&i.EventType,
		&i.Payload,
		&i.Timestamp,
		&i.StatusCode,
		&i.ResponseBody,
		&i.ErrorMessage,
		&i.DurationMs,
		&i.Success,
		&i.RetryCount,
	)
	return i, err
}

const deleteWebhook = `-- name: DeleteWebhook :exec
DELETE FROM webhooks WHERE id = $1
`

func (q *Queries) DeleteWebhook(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteWebhook, id)
	return err
}

const getActiveWebhooks = `-- name: GetActiveWebhooks :many
SELECT id, url, description, enabled, events, project_id, environments, secret, max_retries, timeout_seconds, created_at, updated_at, last_triggered_at FROM webhooks WHERE enabled = true ORDER BY created_at DESC
`

func (q *Queries) GetActiveWebhooks(ctx context.Context) ([]Webhook, error) {
	rows, err := q.db.Query(ctx, getActiveWebhooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Webhook
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Description,
			&i.Enabled,
			&i.Events,
			&i.ProjectID,
			&i.Environments,
			&i.Secret,
			&i.MaxRetries,
			&i.TimeoutSeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastTriggeredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWebhook = `-- name: GetWebhook :one
SELECT id, url, description, enabled, events, project_id, environments, secret, max_retries, timeout_seconds, created_at, updated_at, last_triggered_at FROM webhooks WHERE id = $1
`

func (q *Queries) GetWebhook(ctx context.Context, id pgtype.UUID) (Webhook, error) {
	row := q.db.QueryRow(ctx, getWebhook, id)
	var i Webhook
	err := row.Scan(
		&i.ID,
		&i.Url,
		&i.Description,
		&i.Enabled,
		&i.Events,
		&i.ProjectID,
		&i.Environments,
		&i.Secret,
		&i.MaxRetries,
		&i.TimeoutSeconds,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastTriggeredAt,
	)
	return i, err
}

const listWebhookDeliveries = `-- name: ListWebhookDeliveries :many
SELECT id, webhook_id, event_type, payload, timestamp, status_code, response_body, error_message, duration_ms, success, retry_count FROM webhook_deliveries 
WHERE webhook_id = $1 
ORDER BY timestamp DESC 
LIMIT $2 OFFSET $3
`

type ListWebhookDeliveriesParams struct {
	WebhookID pgtype.UUID `json:"webhook_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListWebhookDeliveries(ctx context.Context, arg ListWebhookDeliveriesParams) ([]WebhookDelivery, error) {
	rows, err := q.db.Query(ctx, listWebhookDeliveries, arg.WebhookID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WebhookDelivery
	for rows.Next() {
		var i WebhookDelivery
		if err := rows.Scan(
			&i.ID,
			&i.WebhookID,
			&i.EventType,
			&i.Payload,
			&i.Timestamp,
			&i.StatusCode,
			&i.ResponseBody,
			&i.ErrorMessage,
			&i.DurationMs,
			&i.Success,
			&i.RetryCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWebhooks = `-- name: ListWebhooks :many
SELECT id, url, description, enabled, events, project_id, environments, secret, max_retries, timeout_seconds, created_at, updated_at, last_triggered_at FROM webhooks ORDER BY created_at DESC
`

func (q *Queries) ListWebhooks(ctx context.Context) ([]Webhook, error) {
	rows, err := q.db.Query(ctx, listWebhooks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Webhook
	for rows.Next() {
		var i Webhook
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Description,
			&i.Enabled,
			&i.Events,
			&i.ProjectID,
			&i.Environments,
			&i.Secret,
			&i.MaxRetries,
			&i.TimeoutSeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastTriggeredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWebhook = `-- name: UpdateWebhook :exec
UPDATE webhooks SET 
  url = $2, 
  description = $3, 
  enabled = $4, 
  events = $5,
  project_id = $6, 
  environments = $7, 
  max_retries = $8,
  timeout_seconds = $9, 
  updated_at = now()
WHERE id = $1
`

type UpdateWebhookParams struct {
	ID             pgtype.UUID `json:"id"`
	Url            string      `json:"url"`
	Description    pgtype.Text `json:"description"`
	Enabled        bool        `json:"enabled"`
	Events         []string    `json:"events"`
	ProjectID      pgtype.UUID `json:"project_id"`
	Environments   []string    `json:"environments"`
	MaxRetries     int32       `json:"max_retries"`
	TimeoutSeconds int32       `json:"timeout_seconds"`
}

func (q *Queries) UpdateWebhook(ctx context.Context, arg UpdateWebhookParams) error {
	_, err := q.db.Exec(ctx, updateWebhook,
		arg.ID,
		arg.Url,
		arg.Description,
		arg.Enabled,
		arg.Events,
		arg.ProjectID,
		arg.Environments,
		arg.MaxRetries,
		arg.TimeoutSeconds,
	)
	return err
}

const updateWebhookLastTriggered = `-- name: UpdateWebhookLastTriggered :exec
UPDATE webhooks SET last_triggered_at = now() WHERE id = $1
`

func (q *Queries) UpdateWebhookLastTriggered(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateWebhookLastTriggered, id)
	return err
}
